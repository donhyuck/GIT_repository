package a_Constructor02;

public class Main {
	public static void main(String[] args) {
		System.out.println("===a칼전사1===");
		전사 a칼전사1 = new 전사();
//		a칼전사1.세팅();  --> 삭제
		a칼전사1.공격();
		a칼전사1.이름 = "영수";
		a칼전사1.공격();

		System.out.println("===a칼전사2===");
		전사 a칼전사2 = new 전사();
//		a칼전사2.세팅();  --> 삭제
		a칼전사2.이름 = "영희";
//		a칼전사2.a무기 = new 칼();
		a칼전사2.공격();
	}
}

// 이름을 정하지 않아도 기본적으로 전사의 이름이 철수이고 싶다.
class 전사 {
	String 이름;
	무기 a무기;

	void 공격() {
		a무기.작동(이름);
	}

	// 전사가 태어나고 세팅을 누르면
	// 이름을 철수도 바꾸고 무기를 칼로 둔다.
	// 세팅의 역할 : 전사 객체가 태어나면 기본적으로 지니고 있기를 원하는 것
	// 없으면 오류가 난다.

	// 그래서 사용자가 전사객체마다 세팅을 호출해야한다.
	// 가장 좋은 것은 세팅호출 없이도 전사객체와 함께 설정되는 것이다.
	/*
	 * void 세팅() {
	 *  this.이름 = "철수";
	 *  this.a무기 = new 칼(); 
	 *  }
	 */
	// 세팅과 같은 역할을 하는 것이 생성자
	// 1) 리턴 타입 제거 2) 클래스와 동일한 이름의 생성자
	// 생성자는 new전사() 와 함께 실행된다.
	전사() {
		this.이름 = "철수";
		this.a무기 = new 칼();
	}

}

class 무기 {
	void 작동(String 공격자명) {
	}
}

class 칼 extends 무기 {
	void 작동(String 공격자명) {
		System.out.printf("%s이(가) 칼로 공격합니다.\n", 공격자명);
	}
}